#### 腾讯

腾讯一面：

+ Spring AOP、动态代理、应用过程中使用的是哪种代理、两种代理的性能差别

+ 缓存击穿、雪崩 =》 限流

+ 分布式锁 ：考虑那几个问题

  ```
  key 过期时长: redission 看门狗动态延长过期时长！
  是否是原子性的设置过期时间:setnx 原子性的设定 过期时间！
  当前线程设置的锁其他线程不可解锁:绑定线程id！
  ```

+ 消息中间件（没了解过）

+ redis 的基础知识：5 种基本类型讲出来就行

+ redis 持久化方式、集群方式

+ 线程池：工作方式、淘汰策略、FixedThreadPool（~）、自己使用的是哪种方式

+ JVM 运行时数据区、在方法种new一个对象，存放在哪儿的（堆？栈？）

+ 设计模式（说一种用过的）

+ ReentrnatLock 如何实现可重入性、是哪种锁！

+ 微服务架构（没了解过）

+ 规划

#### 阿里

阿里一面

+ 正在学习的专业课：计算机网络
+ 为什么会开发这两个系统（开发背景）
+ 系统中的角色、介绍一下自己的工作
+ 教学系统：工作中的亮点，这个亮点实现的过程中你觉得难点在哪里，如何解决？
+ 跟着做网课做系统的过程中，你有什么修改或者优化的地方，为什么要修改？
+ 有看技术的博客、论坛？看的是哪个方面？
+ SpringMVC 的运行原理？
+ SpringBoot 启动过程？
+ session 分布式共享的哪些方式？
+ 规划

**阿里二面：查漏补缺！**

+ 缓存使用什么方式设计的，用的什么缓存机制？

  ```
  使用 Redis 设计的缓存
  ```

+ 因为缓存技术有很多种，为什么使用 Redis？有没有对比过其他的缓存机制？

+ 追问：你设计缓存只是为了防止 DB 的压力，其实本身来说 挡住请求 就可以了，如果真的说缓存出现短期的问题的话，DB 这一层做一个保护就可以了，为什么持久化机制就这么重要呢？

  ```
  答：因为我的 阅读量、评论量、点赞量 其实是永久存储在 缓存 中的，然后启动一个定时任务，定期刷新到缓存。
  	并且之后扩展应用的时候，也会非常方便！
  ```

+ 追问：数据的一致性如何保证？

  ```
  答：对于 阅读量、评论量、点赞量 这三个指标其实我并没有随时刷新到数据库，那么这种缓存呢，我使用的就是 定时任务刷新到数据库！
  	对于 博客文章，用户修改之后就是要刷新到数据库的，因此 这种缓存，我是清除 缓存中相关的 博客文章，修改数据库之后，下一次访问到这篇文章的时候，就重新刷新到缓存！
  	
  	这里可以说一下为什么这么做！
  ```

+ 那这个时候，是每两个小时从 缓存中刷新到数据库 对不对，那么缓存也可能出现异常，那这个时候数据丢失怎么办！

  因为你缓存的话用的是 Redis，如果 Redis 集群出问题了，起不来，或者其他原因，导致数据丢失了！

  ```
  答：分布式事务，想了一下，不可以，是我理解错了！
  	补充，这个定时任务其实是可以动态设定刷新时长的，如果某个时刻正好是访问量高峰，则刷新到缓存时长可以设置的短一点
  ```

+ 博客系统是你一个人做练习的，还是和团队一起做的，其他的设计是 按照网课搭建的，还是说自己从 0到1 写的！

+ 整个博客，除了说缓存设计多了一层考虑之外，还有没有别的东西是自己 改动/设计 的嘛？

  ```
  答：对于其他的功能点，我还没有做进一步的优化或者是更新，但是呢，我在网课实现的过程中呢，没有使用 网课上挑选的技术栈，比例说，网课中的使用了 JPA 做数据持久化框架，而我使用的是 MyBatis，数据源他用的是 Spring 默认的，而我使用的是 阿里巴巴的 Druid！

  这里可以说一下，为什么要使用这些技术栈！
  ```

+ 博客的实现过程中，你觉得哪些是有难度的，或者说克服过什么困难？

  ```
  巴拉巴拉，我说的是啥玩意儿！
  ```

  ----

+ 教学系统，你是基于什么背景去做的！

+ 这个系统是作为一个练习，还是说投入使用的？

+ 这个系统是几个人在做，你重点负责什么？

+ 你们三个项目小组的 三个系统组成一个系统的时候，联调阶段 有没有出现什么问题！

  有测试过嘛？

  ```
  答：我们实现的是不同的模块，模块与模块之间是没有关联的，要是说有关联的话，那就是登录状态、登录信息的同步，还有就是数据库的使用是相互关联的！
  ```

+ 那学校那边会有人反映 bug 给你们修复，那你有印象的 bug 是什么，最有印象的 bug 是什么？

  ```
  答：对于我那个模块，没有技术难点，目前还没有收到过 bug
  ```

+ 那假设某个时刻，出现高并发访问，你们的系统是怎样的考虑抵挡高并发的？

  ```
  答：
  1. 我首先会检查应用程序本身是否会存在性能问题！
  2. 数据库能够支持高并发的访问，如果不能的话，那就需要使用 主从、分库分表，让读写压力分摊到不同的数据库上！
  3. 使用缓存，让更多的查询压力，分摊到 缓存的服务器上，如果说缓存服务器并发量也是非常高，承受不住的话，还是会考虑主从+哨兵 或者是 直接上集群。
  4. 如果说一个应用实例 不足以 支撑并发的访问的话，那么使用多个实例，然后前端使用 Nginx 做负载均衡
  ```

+ 除了这两个项目之外，还有没有别的？（明显是不满意我的这两个项目 / 或者说不满意我的回答）

+ 那你知道 JVM 的内存管理机制嘛？

+ 数据库问题（手写 SQL）

  ```sql
  # 一张 course 表，字段为 student_name、subject、score 三个字段！
  # 问：找出 学生平均成绩最高的，前10名，学生的姓名！
  # 答：
  select a.name
  from 
  (
      select name,sum(score)/count(subject) as ave 
      from course group by name
  ) a order by a.ave DESC 
  limit 10;

   insert into course(name,subject,score) value('c','math',100),('c','chinese',67),('d','math',88),('d','chinese',90),('e','math',60),('e','chinese',87),('f','math',96),('f','chinese',70),('g','math',80),('g','chinese',90),('h','math',93),('h','chinese',89),('i','math',96),('i','chinese',90),('j','math',91),('j','chinese',88),('k','math',89),('k','chinese',85),('l','math',90),('l','chinese',88),('m','math',96),('m','chinese',77),('n','math',90),('n','chinese',99);
   
   select count(score)/count(subject) as ave from course group by student_name order by ave DESC limit 10;
  ```

+ 知道哪些算法？

+ 算法题：

  ```
  员工做公益获得积分，只能在空闲的时候，做公益，并且只有公益要求的时间段内，全程参与，才有机会获得积分！
  例如某员工的空闲时间段：10:00 - 14:00、15:00 - 19:00
  现在有多个公益任务：
  	10:00 - 11:00 2积分 公益A
  	10:00 - 14:00 3积分 公益B
  	11:00 - 12:00 1积分 公益C
  	11:00 - 12:00 2积分 公益D
  	14:00 - 15:00 1积分 公益E
  	...
  求：某个员工在一天内，能够获得的最大积分？
  ```
  这个题，使用 dp 的思路:

  ```
  dp[i][j] : 
  	i = 员工的第 i 个时间段
  	j = 第 j 个公益活动的时间段
  	
  思想：【！！！使用公益活动的时间段填充员工的空闲时间段！！！】
  	dp[i][j] 表示员工的第 i 个空闲时间，到第 j 个公益活动为止，能够得到第最大积分
  	
  递推式：
  	dp[i][j] = value(j) + dp[i][k] : (j.st >= i.st and j.end <= i.end) and (k.st >= i.st and k.end <= j.st) 
  	dp[i][j] = value(j) : j.st >= i.st and j.end <= i.end
  	
  	然后纪录每个 i 的 max(dp[j])，并相加即可！
  ```

  ```java
  public class Main{
    private int maxValue(int[][] freeTime, int[][] activityTime, int[] values){
      int[][] dp = new int[freeTime.length][activityTime.length];
      int value = 0;
      for(int i = 0; i < freeTime.length; ++i){
        int timeMaxValue = 0;
        for(int j = 0; j < activityTime.length; ++j){
          if(activityTime[j][0] >= freeTime[i][0] and activityTime[j][1] <= freeTime[i][1]){
            dp[i][j] = values[j];
            if(true) { 
              /*
               todo : 查找 dp[i][k]:我的想法：做一个得分纪录！
                如果在 j 这个活动得到分，则将该时间区间纪录到 LinkedList 中。
                如果前面有员工在做 j 活动之前依旧有空闲时间，则遍历 list，从中找出 max value 的时间段，
                将当前 j 活动的 vlaue 与之前空闲时间段内的 value 相加，作为新的 dp[i][j] 的value，
                并将生成新的时间段：[pre_max_st, j_end]，将该时间段的 vlaue 存入 list
              */
              dp[i][j] += dp[i][k];
            }
          }
          if(dp[i][j] > timeMaxValue){
            timeMaxValue = dp[i][j];
          }
        }
        value += timeMaxValue;
      }
    }
    return value;
  }
  ```

  ​

  ​

