【 cvte_1面 】

+ 项目：说一下技术难点、亮点

  ```xml
  <!--
  我的项目：
  1、完成学习目标的基本管理。
  2、使用短信服务，完成短信验证码登录注册系统。
  3、利用 JWT 设计了分布式应用下的身份认证机制，配合 Redis 完成分布式 session 的管理，使得不同小组的应用之间能够无影响的访问。
  4、部署系统，并使用 nginx 服务器的代理功能完成请求的分发。
  -->
  
  <!--
  =》问：
  	说一下项目中的技术难点、有哪些亮点！
  =》答：
  	JWT 做身份认证：整个过程
  =》问：（对 JWT 毫无兴趣）
  	我看见你使用的短信服务是吧！那来说说短信服务，如果有人恶意攻击，恶意获取短信验证码，该怎么解决？比如，攻击者发送几千上万个短信服务请求，这些请求都是无效请求，由于短信服务是需要向服务商付费的，如果我通过这个攻击你的网站，你该如何解决？
  =》答：（我完全没有想象过这个场景）
  	（我理解成攻击者只用一个手机号进行攻击了：其实阿里短信服务，每个号码每天只能限制10条短信，每小时限制 5 条短信）
  	我会记录攻击者的id、session 放到 redis中做个缓存，用户发器短信服务请求时，首先判断缓存中是否存在id、session等数据，如果存在，则说明缓存内部数据还未过期，说明用户短时间内连续访问，则将其拦截！
  =》问：（显然，我理解错了，他对这个回答毫无波澜）
  	那如果攻击者找来 10000 个手机号，攻击你短信服务？
  =》答：
  	攻击者找来这么多号码对我的系统进行攻击，那他一定是在同一个ip上对我的服务发起的请求，于是我可以限制攻击者的 ip 访问，要实现的话，也是会记录请求者的ip，并设置过期时长，当下一个短信请求过来时，如果还没有失效，就将其拦截！
  
  =》问：（很明显，又没回答到他想要的）
  	然后还有其他的想法、解决方案嘛？
  	你这是针对特殊教育的系统是吧，很可能这个学校只有一个公网ip，那么这些学生都用这个公网ip对你的服务访问，是不是就不能访问了？（面试官没这么问，这个可以通过限制对ip进行判断，校内ip任意访问，校外ip限制时限访问。估计面试官认为我上面的回答是这么想的，就直接问了下一条）
  	如果攻击者，正好利用这个学校的公网ip对你的系统进行攻击呢？这个学校不是就整天得不到访问你的服务了嘛？你怎么解决？
  
  =》答：(......啊，这谁顶得住)额，暂时没想到解决方案。
  -->
  ```

+ 我们聊一下redis吧，看你使用了 redis 做保存 session 的服务

  ```xml
  <!--
  =》问：
  	redis里面有哪些数据结构？
  =》答：(好吧，我作弊了，打开电脑看了)
  	redis 里面有 String 类型的数据结构，还有 hash 其实它那个 hash 就类似于 java 里面的 map ，然后还有 list 链表结构 主要是 pop、push获取元素等，他其实是个双端队列这样一个底层数据结构；然后还有 set ，set是 String 类型的无序集合，但是里面的元素是不可重复的，set 是通过 hashtable 实现的，可以方便我们取交集、并集或者差集；然后 set 对应还有一个 zset ，这是个 有序的 set 
  
  =》问：
  	假如我有这么一个场景，我有一个排行榜的服务，使用 redis 去实现，你觉得用哪种数据结构比较好？比如玩游戏吧，有人玩第一第二第三这种，可能有总榜单，这种应该用什么？
  =》答：
  	用 zset ，zset 里面有个 score ，它可以记录数据的...，可以你自己定义数据的大小，通过那个 socre 来完成排序，就可以实现排行榜！（确实没准备，哎，落下了没有技术的泪水）
  -->
  ```

+ nginx 这一块你有接触是吗？

  ```xml
  <!--
  =》问：nginx 这一块你有接触是吗？
  =》答：对，是有简单的接触，因为我们的后端是3个服务，整个系统对外开放一个80端口，其他端口全部都是隐蔽的（艹，这里不应该说成屏蔽嘛，我这嘴），所以需要用 nginx 做反向代理！把请求转发到我们各个后端！
  
  =》问：（原来他想问这个）
  	简单说，你每个服务有多个实例嘛，那你 nginx 是要做负载均衡是吧，那做负载均衡时有哪些策略，常用的策略？
  =》答：（这个我是真的没有复习到，也不记得策略的名称叫啥，就这样说吧，吐血！）
  	可以对负载均衡的多个实例服务做那个顺序访问，顺序转发那个请求，也可以对那些服务设置权值，权值大的，把那个请求多转发到一些那个权值大的服务上去！
  
  =》问：基于什么考虑设置这些权值呢，为什么有一些权值大，有一些权值小？
  =》答：一般时基于你的服务的性能，承载访问的压力，性能有多高，一般是针对这个！如果服务性能好，可以支持大并发的话，就可以把权值设置大一点，尽量转发多的服务到这个服务上来。
  -->
  ```

+ 然后我在问一些其他问题（看来想试探我有没有亮点，怕不是已经对我大打折扣了）

+ 你常用的java 集合都有哪些

  ```java
  /*
  =》问：
  	你常用的 java 集合都有哪些？
  =》答：
  	常用的集合嘛？常用的有 ArrayList，还有，其实都有在用，还有 Hashmap 也在用
  =》问：那就直接问吧，就，hashmap 内部实现大概说一下吧！
  =》答：
  	hashmap 是 hash表+链表或者是红黑树 实现的。然后，（开始了，卡顿），hash 表中的每一个元素就对应着一个hash桶，就是一个链表或者是一颗红黑树。元素是怎么定位到hash桶的呢，是通过元素的一个hash值，通过 hashcode 计算它的hash码，定位到hash表里面的一个hash桶，然后进行存储（卧槽，你tm这是回答的什么？）。
  =》问：
  	那刚刚说到红黑树嘛，为什么会用到红黑树呢？
  =》答：
  	因为链表结构，如果一个，如果出现大量的元素，它的hash码，和那个，在那个hash表上的hash桶，全部对应在一个里面的话，桶的容量就会变的非常大，如果使用link（这里说错了，应该是list）的话就不方便存取（其实还有查询），因为link访问都是顺序访问，所以可以用红黑树做一个优化（一大堆废话）
  */
  ```

+ Java 虚拟机这一块，我也问一些东西哈

  ```java
  /*
  =》问：
  	然后垃圾回收这一块，一个对象什么情况下被回收？
  =》答：
  	一个对象，额，当一个对象没有被任何的，额，就是 GC roots那个结点与它相连的话，说明这个对象就是可能会被回收的，但是它何时被回收会经过两次标记。第一次虚拟机会检测这个对象是否有必要执行 finalize() 方法，如果没有必要，如果没有必要，一般就是就是虚拟机已经执行或那个方法，或者是它根本就没有覆盖这个方法，所以没有必要的时候，这个对象会被回收！如果有必要执行的话，就会再去执行，就会把这个对象放在一个队列里边，然后启用一个低优先级的线程，去触发这些对象的 finalize() 方法，嗯，对！如果最后执行之后，那个对象还没有被成功的解救的话，就会被回收。
  	
  =》问：
  	嗯，你刚刚说到GC root，什么样的对象会被做成gc root？
  =》答：
  	嗯，在虚拟机栈里面那个局部变量表上的，虚拟机栈上的变量可以作为gc root，虚拟机栈局部变量表里面的变量可以作为 gc root，还有静态常量，还有静态变量都可以作为gc root（好像还少一个）
  
  =》问：在分代回收里面，垃圾回收的策略有哪些？
  =》答：
  	额，垃圾回收的策略！
  	首先对象会被分配到 伊甸园区，如果伊甸园区对象，如果伊甸园区，内个空间满了就会进行一次 Minor GC，如果存活下来，对象会进入到 survivor 区，然后对应的它那个年龄值就会设置成1。然后大对象一般是直接进入到老年代区，大对象是那种，具有连续的连续，需要大量的连续空间来存储的那种对象，就一般直接放到老年代，如果老年代不够就会进行一次，哦，不是这个。如果在survivor 区，对象年龄阈值达到了 15 ，默认是15，就会进入到老年代。然后当survivor里面年龄，某一年龄，平额，某一年龄值的对象，平均年龄值的对象所占用的空间，大于survivor区一半的空间，就会直接进入到老年代，这就不需要达到年龄阈值。还有个就是，老年代会做一个空间担保，在 jdk 6 更新24版之前，他会检查，如果，如果经过一次Minor GC之后，如果老年代剩余的空间，连续最大空间大于新生代所有对象空间的话，那可以放心的进行一次 Minor GC，然后，如果小于的话，它会检查一个，他会检查一个 JVM 参数参数叫 HandlePromotionFailure 是，就是做空间担保这个参数，如果这个参数是 true的话，它就会再次检查 老年代剩余的空间，剩余的连续最大空间是否大于历次晋升到老年代所有对象所占用的空间，额，平均空间，历次晋升到老年代的平均对象所占用的平均空间，如果大于的话，则认为这次可以进行一次 Minor GC，尽管它是有风险的，仍然是可以，如果是 false 的话就说明，不会被担保，那可能，那就需要进行一次 Full GC，如果老年代的剩余的最大连续空间小于 survivor 区的全部，小于新生代对象所占用空间的话，就会直接进行Full GC
  */
  ```

+ 好了，我知道了，然后，我们先跳过这个问题，额，就是给你一个场景吧，然后假设我们有一个文件，它里面有1千万个数据，然后数字的话是不会连续的，就是额，就不会重复的，然后它里面的数据也是乱序的，现在也是想把这个文件的进行排序，要么从大到小，要么从小到大，这样排序出来就ok了，但是有个限制，内存只有1M，然后硬盘的话是 无限，然后一个数字，一个数字4个字节嘛，然后基于这个场景，你怎么去把这个文件进行排！

  ```java
  /*
  解决方法：bitmap
  */
  ```

  

+ emmm从刚刚的面试情况来看的话，就，额，稍微来说就是很多知识点，可能就是接触的比较【浅】一点，然后向之前做的项目这一块，因为它里面可能会有很多知识点的，因为做的项目也比较小，可能也没有遇到业务难点，就是很多时候你可能在接触一个新的项目的时候，你除了要思考，处理老师交给你任务，还要去对他进行扩展，就是怎么对它进行优化这一块！然后算法这些东西，可能需要更多的关注一下！