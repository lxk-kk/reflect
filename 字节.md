##### 项目

1. 为什么 Token 比 Cookie 好？

   同样会涉及到身份泄密

   ```
   答：
    1. Token 自身是无状态的，只用来验证！用户的的状态，则验证通过之后，会从 Redis 中获取。
   	Cookie 是有用户状态的，它就是为了解决 Http 无状态而出现的。
      虽然 Token 和 Cookie 都可能被盗用，但是，Token 并不会暴露用户的身份信息，包括一些隐私信息。而 Cookie 则会直接将用户的身份信息暴露出去。
      
    2. Token 可能会被盗用，导致攻击者冒充正常用户。但是这个问题是可以被解决的。而 Cookie 导致身份信息直接暴露，是无法解决的。
    	通过 Token 的验证机制，可以用来判断 Token 是否被篡改，是否被盗用，方案就是将 用户的唯一标志作为用户 Token 加盐的一部分，例如 IP、设备信息！甚至可以使用 https 最大化的保证通信过程的安全性。
    	Cookie 可以设置 HttpOnly 属性，这样虽然可以避免 js 脚本的攻击，但是应用自身也受到了限制，无法使用 js 读取 Cookie。
   ```

2. 项目中写了就要清楚！！！

##### 开放性

1. [Redis 内存碎片处理](https://blog.csdn.net/F_Hello_World/article/details/103848703?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase)

   ```
   1. 在 redis 4.0 之前的版本中，只能通过正确的重启 Redis 服务解决内存碎片问题。
   2. 在 redis 4.0 之后，有两种方式整理内存碎片：
   	（1）通过手动命令触发：memory purge
   	（2）通过配置文件（配置 activedefrag yes），使 redis 在运行时就能自动进行内存碎片清理。
   	
   	内存碎片的整理由主线程处理，redis 是单线程的，内存碎片整理的操作会 scan 扫描整个 redis 结点，并进行 内存的 复制、转移 等操作。
   	如果频繁触发内存整理，肯定会导致 redis 服务整体响应时间变长，因此，redis 对配置自动整理的方式给出了警告：使用该功能之前首先进行压力测试已经功能评估。
   ```

2. [栈为什么比堆快](https://blog.csdn.net/qq_20553613/article/details/77972694?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.edu_weight)

   ```
    1. 栈是线程私有，在线程创建时，就会为其分配栈的内存空间；在在操作系统层面，栈是机器系统提供的数据结构，有专门的寄存器支持。
   	堆是线程共享的，用于存放对象，堆的内存空间在虚拟机启动时就会分配。但是线程执行的过程中，虚拟机会动态在堆中为线程分配所需要的内存。并且堆是 C++函数库提供的，机制比较复杂（涉及到：空闲内存的查询，内存碎片的整理），
      因此，就线程执行过程中的内存分配而言，堆需要动态分配，而栈直接拥有，因此栈比堆快！
      
    2. 访问堆上的数据要比访问栈上的数据多一次寻址（对象在堆中分配，在栈中保存其引用，基本数据类型直接在栈上访问。）
    
    3. 内存释放方面：一个方法的执行就对应一个栈帧的入栈和出栈，栈的内存由系统分配和释放。
    	堆上的内存，很大部分取决于程序员，如果对象无用了，但是程序一直持有该对象的引用，就会导致无法释放内存，导致内存泄漏。
   ```

3. 磁盘容量 1G、内存大小为 128 M，如何统计某一句话出现的次数？

   注意：Java 中 File 类会将文件一次性加载到内存中

   + Java 中的 **File** 会将文件整个读取到内存中

     读取文件行的标准方式是在内存中读取，Guava 和 Apache Commons IO 都提供了快速读取文件行的方法：

     ```java
     Files.readLinex(new File("path"), Charsets.UTF_8);
     FileUtils.redadLines(new File("path"));
     // 这种方法会导致所有文件行都被加载到内存中，当文件足够大时，就会导致 OOM
     ```

   + Java 中的**文件流**可以实现 按需读取（每个字节、每行）

     ```java
     FileInputStream fileStream = new FileInputStream("path");
     Scanner readLine = new Scanner(fileStream, UTF-8);
     while(readLine.hasNextLine()){
         String line = readLine.nextLine();
         // 操作
     }
     // 这种方式允许对每一行进行处理，并且不会在内存中存储。
     ```

   + 详见：

     [Java 解决大文件读取的内存问题以及文件流的比较](https://www.cnblogs.com/hulichao/p/java_io.html)

     [Java 高效读取大文件，内存占用少](https://blog.csdn.net/qq_24607837/article/details/80192083)

4. 设计一个框架整合 JDBC ORM 框架 和 Jedis，实现同时操作 mysql 和 jedis

   需要详细设计每个类、各个组件的关系、如何 run 起来

   需要写下设计的思路，每个类和组件的作用，需要说明使用的 设计模式 等，围绕一个框架不断的细化

   ```
   作者：加油鸭oo
   我是参照mybatis，引入了xml解析，自定义sql。然后参照hibernate做了ORM关系映射。最后参照mongoDB的Criteria做了redis一块的自定义逻辑。然后参照通用mapper提供了一些通用的crud操作，总体而言就是个缝合怪
   ```

5. sql

   ```
    sql 给你一个goods表，其中day和itemId构成联合主键 
    day         itemId      num
    20190109    'A'         4
    20190109    'B'         5 
    20190110    'D'         1 
    20190111    'A'         3
    20190111    'B'         5
    20190111    'C'         4
    20190112    'C'         4
    写出一个查询语句，查找出2019 01 09~2019 01 11（连头连尾）中的，每天销量最大的
    查询结果应该是:
    20190109    'B'         5
    20190110    'D'         1
    20190111    'B'         5
   ```

   [group by 和 max 使用误区](https://www.cnblogs.com/jpfss/p/9187296.html)

6. 几个 G 的日志文件，无法放入内存，已经按照时间排序，找到时间 t1 和 t2 之间的日志

   使用二分？如何做磁盘二分

7. 统计用户再一段时间的行为次数，怎么设计数据结构

   下面两个函数用的时间都是函数调用的时间：add(user, action) getCount(user, action, duration)

   假设当前时间为 t，就是 t - duration 到当前时间的次数

   这种数据结构，抖音每天都需要多少存储空间，并发写会不会有问题，能不能加锁实现并发操作的安全性

8. 前缀树的应用场景

9. 怎么实现一个无锁队列？无锁队列如何避免 ABA 问题（简单写一下代码）

10. sql

  ```
  两张表，一张学生表，存放id、性别、姓名，另外一张成绩表，存放学生id和成绩，求成绩最大的学生姓名
  ```

11. 统计一个日志文件前 10 个出现的 id，更深入，如果日志文件很大，内存放不下，放在外村该怎么做

    ```
    先分块、hash 或者 驱魔都可以做到
    ```

12. 外部有个大文件，内存放不下，应该如何处理

    ```
    分块 + 多线程 mmap，可以使用 Hash 映射，mmap 如何及逆行内存映射的
    ```

13. 栈效率为什么比堆块？都有哪些用处和区别

    ```
    首先答了多线程共享资源问题，从Java角度解释，多线程每个线程维护自己的栈，但堆是共享，会出现资源争夺的问题。其次从资源回收角度介绍了一下， 堆中的对象需要我们手动释放或者JVM回收，栈中的数据通常伴随着方***压栈或者弹出，从两个角度介绍
    ```

14. rpc 调用过程

15. 未来规划

##### 算法

1. 统计树的宽度（结点最多的那一层的结点总数）：广度优先遍历、层序遍历

2. 树中两个结点的公共父结点

3. 最小未出现正数（leecode 41）

4. 模拟 Raft 算法投票（时间复杂度 O(n) 空间复杂度 O(1) ）

5. [二叉树左视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

6. [零钱兑换](https://leetcode-cn.com/problems/coin-change/)

7. 树的最长路径

8. 拷贝带有随机指针的链表

9. 132 模式

10. 有很多个无序数（数据没有范围，可正可负，可以非常大），一个个读入，想一个办法再任意时刻，返回已读的数字的中位数

11. 给出一个场景，我要看电视剧，但是我下载的集数是比较分散的，求出我能看的最大的连续集数，比如[9,8,5,3,6,7]，我能看的最大的连续集数就是[5,6,7,8,9]即5集，比如[8,5,3,7,4,1,11]，我能看的最大的连续集数就是[3,4,5]即3集。

    ```
    sort + 遍历
    set + 遍历（set 判断下一个是否存在）
    ```

12. 给一个有序数组，求每个数的平方根的结果，不重复的有几个

    ```
    -5，-5，-1，0，1，1，1，1，2，5
    这里平方数不重复的一共4个
    怎么样用O(1)的空间复杂度实现 
    ```

13. 反转链表

14. 图遍历

15. TwoSum

16. leetcode347

17. 括号匹配算法

18. 最长不重复子串

19. 机器人走路算法

20. 左上角到右下角，求可能的路径中 sum 最小的值

21. LRU 算法，手动实现（HashMap + 双链表：Leecode 原题）

22. 给定一个区间 (a,b) 求该区间内不包含 3、5、8 的数量

23. （机器学习平台部门）

    + 翻转的有序数组、不知道旋转点、log 查找值的位置：两次二分

    + 设计 cash 缓存每次访问后更新并删除最久没有访问的内存：hashmap 可以做（linkedhashmap），线段树可以做

    + n 个物品，每个基础价值 ai，第 k 个拿会减去 (k-1)*bi 的价值，要拿 m 个使得总价值最大：dp

    + n 个怪物，每个怪物有攻击 ai，勇者防御初始为 d，每打一只防御 + 1，防御 < ai 的话直接受到 bi 的伤害，问优先打怪的顺序：贪心、并查集
    + 多线程写稀疏矩阵 * 稠密矩阵
    + 二叉树序列化和反序列化 + 校验

##### 操作系统

1. 操作系统中的 fork

2. 进程和线程

3. 操作系统的内存模型

   内存颠簸

4. 操作系统：

   进程、线程、文件系统、linux命令

5. 缺页中断算法

6. linux 查看文件的命令，如果是大文件呢？

   cat、vi、vim

   大文件：less？

   vi 如何跳转到行尾

   vi 如何跳转到指定行

7. Linux 如何查看系统状态

   如何查看进程占用的 CPU 情况

8. 操作系统：[内存、外存、虚拟内存、Cache](https://blog.csdn.net/yongganzhe02/article/details/88711965?utm_medium=distribute.wap_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-88711965.nonecase) 的作用和相关原理

   ```
   外存是 外部的硬件磁盘，为了调和 CPU 访问速度 以及 外部IO 的速度，于是出现了内存，将需要的数据载入 内存，CPU 直接访问内存将会比访问磁盘 速度快很多。

   但是 CPU 与 内存之间依旧存在一定的访问速度差距，此时就出现了高速缓存。
   现代计算机有三级高速缓存，L1、L2、L3，访问速度依次递减，使用缓存就能够最大化的优化数据访问效率，平衡 CPU 执行速度与数据访问速度。

   虚拟内存是 操作系统的一种内存管理机制，它能够通过局部性原理，将某段时间内进程执行所需要的 数据和程序 载入内存中，而其余数据和程序放在外存中，避免一次性的全部载入，这样就能在操作系统内尽可能多的创建进程执行程序。
   ```

##### MySQL

1. 左连接、右连接、内连接的区别

2. 事务是什么，隔离级别，每种隔离级别解决了什么问题

3. 不可重复读是什么问题，怎么解决 ：MVCC

4. 悲观锁、乐观锁、读锁、写锁（数据库中的）

5. 索引有哪些、数据结构是什么，区别是什么

6. 介绍数据库索引

   聚集索引和非聚集索引的区别

   为什么这么设计

7. B+ 树 和 平衡二叉树，平衡二叉树和红黑树对比

8. 磁盘 IO 过程

   ```
   ①单纯从磁盘io这一块的话就是操作系统里面的寻道算法相关的，这一部分不太清楚了就不展开
   ②用户程序发起io请求，并不能直接io，而是需要发起系统调用由操作系统“帮你”io到内核缓冲区，内核io完成后通知用户程序，用户程序再将数据从内核缓冲区复制到自己的用户数据区
   ```

9. MySQL 隔离级别

10. mysql 索引：

  MyISAM 索引结构

  InnoDB 可以使用 hash 表做索引吗

  可使用 二叉搜索树 做索引吗？

  B+ 树

  为什么使用 B+ 树做索引

  ```
   (1)B+树的数据都存储在叶子节点上，而且叶子节点是用指针连接起来的，形成一个单链表的结构，这样方便扫库，只需要遍历一遍叶子节点即可。
  （2）B+树的查询效率更稳定，每一次查询都是从根节点到叶子节点，走过的路径长度是一致的。
  （3）B+树的数据只存储在叶子节点中，分支节点存放索引，而B树分支节点也会存放数据，所以B+树的内部节点大小更小，这样的话对于同一个磁盘块，可以存放更多的B+树内部节点，当把这个内存块读到磁盘中时，包含的关键字就更多，io次数就更少
  ```

11. 数据库四种隔离级别

12. 三种一致性读问题

13. 如果不用串行化，如何解决上述三个问题

14. MySQL 有哪些索引、B+ 树具体结构

15. 聚集索引 和 非聚集索引

##### 网络

1. https 过程

   客户端如何认证证书的有效性

2. http、https

   https 加密过程、加密密钥怎么来的，对称加密密钥哪里生成

3. cookie 和 session

   session 共享

4. http 状态码

5. 输入一个网址的的全过程：各层协议的工作

   ```
   查询是否永久重定向
   查询缓存
   DNS 解析 -> ip

   应用层 -> 传输层：TCP 将应用层传递的数据包，拆分成 报文段，每个段上面添加上 源端口、目标端口。向下层传递
   传输层 -> 网络层：IP 将传输层传递的数据包，拆分成 IP 数据报，在每个数据报上面添加上 源IP、目标 IP。向下层传递。
   网络层 -> 数据链路层：将 数据包 封装成 帧，以帧的格式传递给下一层。
   数据链路层 -> 物理层：物理层实现以 bit 流的形式透明传输。

   然后原路返回响应数据。

   在网络层：如果目标是同网段，则查询 ARP 表，获取目标主机的 MAC 地址。如果目标是非同网段，则根据 路由表找到下一跳的 ip，根据 ip 到 ARP 表中查询目标的 MAC 地址，将数据传递给下一跳。

   在数据链路层：根据 MAC 找到目标主机，并传送数据，这期间需要使用到交换机。
   主机会直接连接到 交换机的端口上，交换机中维护了一个转发表，用于记录 端口->MAC 地址的映射关系。
   交换机具有自学功能，不需要事先将 端口->MAC 之间的映射存入转发表，而是通过广播的形式，自己建立 转发表。
   ```

6. ARP 协议

   ```
   ARP 是一种地址转发协议，记录的是 IP->MAC 地址之间的映射关系，用来定位下一个应该接受到数据包的网络节点的 MAC 地址。
   ```

7. TCP 为什么要三次握手和四次挥手

8. 如何确认发出去的消息没有收到

   超时重传的时间是怎么定的

9. 三次握手可以改成四次握手吗

10. tcp 与 udp：区别、使用场景

  TCP 和 IP 协议的联系

11. http 使用的是 tcp 还是 udp

    tcp？

    httpu？

12. https 和 http 性能对比

##### Java

###### 1. 基础

1. 除 Java 生态还会什么？

   C++ 析构函数、不写析构函数会怎么样，还能释放内存吗

   C++ 和 Java 区别

2. Object 类有哪些方法

3. NIO

   同步异步、阻塞和非阻塞 四个概念

4. 已知 rand(3) 求 rand(5)

   ```
   rand(3): 1, 2, 3
   rand(5): 1, 2, 3, 4, 5

   A = (rand(3) - 1 ) * 3: 0, 3, 6
   B = rand(3) - 1: 0, 1, 2

   A + B = 0 1 2 3 4 5 6 7 8
   A + B + 1 = C = 1 2 3 4 5 6 7 8 9

   C >= 5 去掉!
   0 1 2 3 4

   D = C%5 + 1
   D = 1 2 3 4 5
   ```

###### 2. 多线程

1. 进程和线程的区别

2. 临界区、互斥锁、乐观锁、悲观锁及其使用场景

3. CAS

   自己写代码实现 CAS 的过程可以吗？

   ```
   可以但是要保证原子性，Java 的 CAS 底层是一条机器指令 CMPXHG，机器指令是原子性的。
   ```

   这个实现属于软件实现还是硬件实现？

4. Java 线程池有哪些参数

   核心池如何扩容

5. synchronized 内部实现

6. AQS 如何实现

7. volatile 底层实现

8. 线程状态

9. block 和 wait 区别

10. juc 下的包

11. 原子类的实现

12. CAS 为什么是原子性的

13. 线程池原理

###### 3. 集合

1. HashMap 底层存储、扩容流程

2. hashcode 是什么

3. hashmap 中如何计算下标

4. 如果所有对下个的 hashcode 都为 1，会发生什么？

5. hashset 的内容

6. 讲讲 consurrentHashMap，如果下标空 是怎么操作的

7. ConcurrentHashMap 如何保证并发安全问题

8. Java 默认用的是什么排序

   ```
   sort(int[])，数组长度< 47，用插入排序，47 -  286  使用快排       长度>= 286 ，看看数组是不是基本有序，基本有序用归并排序，基本无序，用快排，而且它的快排是什么双轴快排
   ```


##### JVM

1. 说一说 Java 内存模型
2. volatile 原理
3. 怎么解决数据不一致的问题
4. CMS 和 G1 的区别
5. Java 用的是什么垃圾回收器
6. 什么时候会 垃圾回收

##### Spring

1. Spring Boot 启动顺序
2. SpringBoot 中使用过什么注解
3. Spring 框架中 IOC 和 AOP

##### Redis

1. redis 集群：一致性 hash、redis cluster、主从复制 怎么做的

   集群中一个结点挂了，会发生什么？新的请求打过来会怎么样

   结群中新增一个结点，又会作什么？新的请求打过来会怎么样

2. redis 常用的数据结构，每个结构的底层实现

3. zset 跳表如何实现

   要从跳表中查找一个出现次数最多的元素，流程是什么样的

4. redis 为什么这么快

5. redis 可以做并发吗

   可以

6. 如果有两个 redis 命令，第一个要读取很大的文件，第二个要读取很小的文件，那么第二个命令会被阻塞吗？

   解：会阻塞



##### 面经

1. java 中的 arraylist 和 vector 的区别

2. 数组和链表的区别

3. java 中的锁机制

4. java 中的内存区域

5. 触发 full gc 的情况

6. 用户态和核心态

7. IO 模型

   NIO、BIO、AIO 

8. web server 如何选择，选择的指标是什么

   ```
   吞吐量：固定bai时间间隔内的du处理完毕事务个数。通常是1秒内zhi处理完毕的请求个数，单位：事务/秒（tps）。
   响应时间：一次事务的处理时间。通常指从一个请求发出，到服务器进行处理后返回，再到接收完毕应答数据的时间间隔，单位：毫秒。
   CPU 占用率：表示CPU被使用情况，反映了系统资源利用情况。
   ```

   是什么决定 web server 的并发性能

   ```
   并发就涉及到 线程，能够启动的线程多，说明并发处理的性能好。
   nginx 服务器，只用来接受和转发请求，服务器只会对 请求做过滤做路由 等工作，不涉及到 IO（socket io 除外），整个线程的工作耗时短。吞吐量大！
   tomcat 服务器，默认的请求连接数是 200，这就说明同一个时刻最多只能有 200 个请求被处理。这是因为，tomcat 作为后端服务器，需要频繁做 IO（缓存的 Socket IO、数据库的 磁盘 IO），并且 tomcat 需要在 IO 前后对数据做处理，这也就导致了，tomcat 服务器吞吐量低，并发性能低，如果 Tomcat 启动过多的线程处理请求，可能会导致 IO 竞争严重，锁竞争严重，效率反而会下降。
   ```

   [Nginx 为什么支持高并发](https://www.jianshu.com/p/74aededc3457)

   ​

9. 项目中 缓存的设置

   ```java
   if(cache() == empty){
   	A = readdb;
   	setCache(A)
   	return A;
   }else{
   	getCache();
   }
   // 会出现什么并发安全性？
   ```

10. 代码：

  + 两个线程依次打印 数组

    1 2 3 4 5 6

    A,B 依次分别打印 1、3、5 和 2、4、6 

    A B 依次打印

    ```java
    // 线程之间的通信：加锁 + 线程通信机制

    private static final Object lock = new Object();
    private static int[] arr;
    private static int idx;

    public static void main(String[] args) {
        arr = new int[]{1, 2, 3, 4, 5, 6, 7, 8};
        Job job= new Job();
        Thread a = new Thread(job);
        Thread b = new Thread(job);
        a.start();
        b.start();
    }

    private static class Job implements Runnable {
        @Override
        public void run() {
            while (idx < arr.length) {
                synchronized (lock) {
                    System.out.println(arr[idx]);
                    idx++;
                    lock.notifyAll(); // 唤醒下一个线程
                    try {
                        lock.wait(); // 当前线程等待
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ```

  + 数组之中 三个数之和为 target

    方案：

    1. dp

    2. set 记录任意两数之和

    3. 三个指针：时间O(n^2) 空间O(1)

      ```
      for idA:0~n-1
      	idB:idA + 1
      	idC:n - 1
      	
      	while idB < idC
      		sum == target:print
      		sum > target:idB++
      		sum < target:idC--
      ```

  + 迭代式的快排

    使用辅助栈记录每次的区间（傻，我该说出来的！！！）

11. mysql 中的 数据存储引擎：Innodb 和 MyISAM 之间的区别








